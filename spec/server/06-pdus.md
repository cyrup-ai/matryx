# PDUs (Persistent Data Units)

## Overview

Each PDU contains a single Room Event which the origin server wants to send to the destination.

The `prev_events` field of a PDU identifies the "parents" of the event, and thus establishes a partial ordering on events within the room by linking them into a Directed Acyclic Graph (DAG). The sending server should populate this field with all of the events in the room for which it has not yet seen a child - thus demonstrating that the event comes after all other known events.

### Example DAG Structure

For example, consider a room whose events form the DAG shown below. A server creating a new event in this room should populate the new event's `prev_events` field with both `E4` and `E6`, since neither event yet has a child:

```
E1
^
|
E2 <--- E5
^       ^
|       |
E3      E6
^
|
E4
```

For a full schema of what a PDU looks like, see the room version specification.

## Checks Performed on Receipt of a PDU

Whenever a server receives an event from a remote server, the receiving server must ensure that the event:

1. **[Changed in v1.16]** Is a valid event, otherwise it is dropped. For an event to be valid, it must comply with the event format of that room version. For some room versions, a `room_id` may also be required on the event in order to determine the room version to check the event against. See the event format section of the room version specifications for details on when it is required.

2. **Passes signature checks**, otherwise it is dropped.

3. **Passes hash checks**, otherwise it is redacted before being processed further.

4. **Passes authorization rules based on the event's auth events**, otherwise it is rejected.

5. **Passes authorization rules based on the state before the event**, otherwise it is rejected.

6. **Passes authorization rules based on the current state of the room**, otherwise it is "soft failed".

Further details of these checks, and how to handle failures, are described below.

The Signing Events section has more information on which hashes and signatures are expected on events, and how to calculate them.

## Definitions

### Required Power Level
A given event type has an associated *required power level*. This is given by the current `m.room.power_levels` event. The event type is either listed explicitly in the `events` section or given by either `state_default` or `events_default` depending on if the event is a state event or not.

### Invite Level, Kick Level, Ban Level, Redact Level
The levels given by the `invite`, `kick`, `ban`, and `redact` properties in the current `m.room.power_levels` state. The invite level defaults to 0 if unspecified. The kick level, ban level and redact level each default to 50 if unspecified.

### Target User
For an `m.room.member` state event, the user given by the `state_key` of the event.

## Authorization Rules

The rules governing whether an event is authorized depends on a set of state. A given event is checked multiple times against different sets of state, as specified above. Each room version can have a different algorithm for how the rules work, and which rules are applied. For more detailed information, please see the room version specification.

### Auth Events Selection

The `auth_events` field of a PDU identifies the set of events which give the sender permission to send the event. The `auth_events` for the `m.room.create` event in a room is empty; for other events, it should be the following subset of the room state:

- **[Changed in v1.16]** Depending on the room version, the `m.room.create` event.
- The current `m.room.power_levels` event, if any.
- The sender's current `m.room.member` event, if any.
- If type is `m.room.member`:
  - The target's current `m.room.member` event, if any.
  - If `membership` is `join`, `invite` or `knock`, the current `m.room.join_rules` event, if any.
  - If membership is `invite` and `content` contains a `third_party_invite` property, the current `m.room.third_party_invite` event with `state_key` matching `content.third_party_invite.signed.token`, if any.
  - If `membership` is `join`, `content.join_authorised_via_users_server` is present, and the room version supports restricted rooms, then the `m.room.member` event with `state_key` matching `content.join_authorised_via_users_server`.

## Rejection

If an event is rejected it should neither be relayed to clients nor be included as a prev event in any new events generated by the server. Subsequent events from other servers that reference rejected events should be allowed if they still pass the auth rules. The state used in the checks should be calculated as normal, except not updating with the rejected event where it is a state event.

If an event in an incoming transaction is rejected, this should not cause the transaction request to be responded to with an error response.

## Soft Failure

When the homeserver receives a new event over federation it should also check whether the event passes auth checks based on the current state of the room (as well as based on the state at the event). If the event does not pass the auth checks based on the *current state* of the room (but does pass the auth checks based on the state at that event) it should be "soft failed".

When an event is "soft failed" it should not be relayed to the client nor be referenced by new events created by the homeserver (i.e. they should not be added to the server's list of forward extremities of the room). Soft failed events are otherwise handled as usual.

### Example

As an example consider the event graph:

```
A
 /
B
```

where `B` is a ban of a user `X`. If the user `X` tries to set the topic by sending an event `C` while evading the ban:

```
A
 / \
B   C
```

servers that receive `C` after `B` should soft fail event `C`, and so will neither relay `C` to its clients nor send any events referencing `C`.

If later another server sends an event `D` that references both `B` and `C` (this can happen if it received `C` before `B`):

```
A
 / \
B   C
 \ /
  D
```

then servers will handle `D` as normal. `D` is sent to the servers' clients (assuming `D` passes auth checks). The state at `D` may resolve to a state that includes `C`, in which case clients should also to be told that the state has changed to include `C`. (*Note*: This depends on the exact state resolution algorithm used. In the original version of the algorithm `C` would be in the resolved state, whereas in latter versions the algorithm tries to prioritise the ban over the topic change.)

Note that this is essentially equivalent to the situation where one server doesn't receive `C` at all, and so asks another server for the state of the `C` branch.

Let's go back to the graph before `D` was sent:

```
A
 / \
B   C
```

If all the servers in the room saw `B` before `C` and so soft fail `C`, then any new event `D'` will not reference `C`:

```
A
 / \
B   C
|
D'
```

## Retrieving Event Authorization Information

The homeserver may be missing event authorization information, or wish to check with other servers to ensure it is receiving the correct auth chain. These APIs give the homeserver an avenue for getting the information it needs.

### GET /\_matrix/federation/v1/event\_auth/{roomId}/{eventId}

Retrieves the complete auth chain for a given event.

| Rate-limited: | No |
| Requires authentication: | Yes |

#### Request Parameters
- `roomId` (string, required): The room ID to get the auth chain for
- `eventId` (string, required): The event ID to get the auth chain of

#### Response (200)
The auth chain for the event.

```json
{
  "auth_chain": [
    {
      "content": {
        "see_room_version_spec": "The event format changes depending on the room version."
      },
      "room_id": "!somewhere:example.org",
      "type": "m.room.minimal_pdu"
    }
  ]
}
```

**Fields:**
- `auth_chain` (array, required): The PDUs forming the auth chain of the given event. The event format varies depending on the room version - check the room version specification for precise event formats