use crate::repository::error::RepositoryError;
use futures::Stream;
use matryx_entity::types::Session;
use std::pin::Pin;
use surrealdb::{Connection, Surreal};

pub struct SessionRepository<C: Connection> {
    db: Surreal<C>,
}

impl<C: Connection> SessionRepository<C> {
    pub fn new(db: Surreal<C>) -> Self {
        Self { db }
    }

    pub async fn create(&self, session: &Session) -> Result<Session, RepositoryError> {
        let session_clone = session.clone();
        let created: Option<Session> = self
            .db
            .create(("session", &session.access_token))
            .content(session_clone)
            .await?;

        created.ok_or_else(|| {
            RepositoryError::Database(surrealdb::Error::msg("Failed to create session"))
        })
    }

    pub async fn get_by_token(
        &self,
        access_token: &str,
    ) -> Result<Option<Session>, RepositoryError> {
        let session: Option<Session> = self.db.select(("session", access_token)).await?;
        Ok(session)
    }

    pub async fn get_by_user(&self, user_id: &str) -> Result<Vec<Session>, RepositoryError> {
        let mut result = self
            .db
            .query("SELECT * FROM session WHERE user_id = $user_id")
            .bind(("user_id", user_id.to_string()))
            .await?;

        let sessions: Vec<Session> = result.take(0)?;
        Ok(sessions)
    }

    pub async fn update(&self, session: &Session) -> Result<Session, RepositoryError> {
        let session_clone = session.clone();
        let updated: Option<Session> = self
            .db
            .update(("session", &session.access_token))
            .content(session_clone)
            .await?;

        updated.ok_or_else(|| {
            RepositoryError::NotFound {
                entity_type: "Session".to_string(),
                id: session.access_token.clone(),
            }
        })
    }

    pub async fn delete(&self, access_token: &str) -> Result<(), RepositoryError> {
        let _: Option<Session> = self.db.delete(("session", access_token)).await?;
        Ok(())
    }

    pub async fn delete_by_user(&self, user_id: &str) -> Result<u64, RepositoryError> {
        let mut result = self
            .db
            .query("DELETE session WHERE user_id = $user_id")
            .bind(("user_id", user_id.to_string()))
            .await?;

        let count: Option<u64> = result.take(0)?;
        Ok(count.unwrap_or(0))
    }

    // TODO: Implement LiveQuery subscription when SurrealDB API stabilizes
    pub fn subscribe_changes(
        &self,
        _user_id: Option<&str>,
    ) -> Pin<Box<dyn Stream<Item = Result<Session, RepositoryError>> + Send>> {
        Box::pin(futures::stream::empty())
    }
}
