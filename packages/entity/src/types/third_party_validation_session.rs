use chrono::Utc;
use serde::{Deserialize, Serialize};

/// Third-party identifier validation session
///
/// Represents a temporary session for validating third-party identifiers (email/SMS)
/// before associating them with a Matrix user account. This follows the Matrix
/// Client-Server API specification for 3PID validation flows.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ThirdPartyValidationSession {
    /// Unique session identifier generated by the server
    pub session_id: String,

    /// Client secret provided by the client for session validation
    pub client_secret: String,

    /// Type of third-party identifier ("email" or "msisdn")
    pub medium: String,

    /// The third-party identifier address (email address or phone number)
    pub address: String,

    /// Verification token/code sent to the third-party identifier
    pub verification_token: String,

    /// Whether the third-party identifier has been verified
    pub verified: bool,

    /// Session expiration timestamp (Unix timestamp)
    pub expires_at: i64,

    /// Matrix user ID if session is associated with a user
    pub user_id: Option<String>,

    /// Session creation timestamp (Unix timestamp)
    pub created_at: i64,

    /// Optional validation timestamp when verification was completed
    pub validated_at: Option<i64>,

    /// Number of verification attempts made
    pub attempt_count: u32,

    /// Maximum number of verification attempts allowed
    pub max_attempts: u32,
}

impl ThirdPartyValidationSession {
    /// Create a new validation session
    pub fn new(
        session_id: String,
        client_secret: String,
        medium: String,
        address: String,
        verification_token: String,
        expires_at: i64,
    ) -> Self {
        let now = Utc::now().timestamp();

        Self {
            session_id,
            client_secret,
            medium,
            address,
            verification_token,
            verified: false,
            expires_at,
            user_id: None,
            created_at: now,
            validated_at: None,
            attempt_count: 0,
            max_attempts: 3, // Allow 3 verification attempts
        }
    }

    /// Check if the session has expired
    pub fn is_expired(&self) -> bool {
        Utc::now().timestamp() > self.expires_at
    }

    /// Check if the session is valid for verification
    pub fn is_valid_for_verification(&self) -> bool {
        !self.is_expired() && self.attempt_count < self.max_attempts
    }

    /// Mark session as verified
    pub fn mark_verified(&mut self) {
        self.verified = true;
        self.validated_at = Some(Utc::now().timestamp());
    }

    /// Increment attempt count
    pub fn increment_attempts(&mut self) {
        self.attempt_count += 1;
    }

    /// Check if maximum attempts reached
    pub fn max_attempts_reached(&self) -> bool {
        self.attempt_count >= self.max_attempts
    }

    /// Associate session with a user
    pub fn associate_user(&mut self, user_id: String) {
        self.user_id = Some(user_id);
    }

    /// Get time remaining until expiration in seconds
    pub fn time_until_expiration(&self) -> i64 {
        self.expires_at - Utc::now().timestamp()
    }
}

impl Default for ThirdPartyValidationSession {
    fn default() -> Self {
        let now = Utc::now().timestamp();

        Self {
            session_id: String::new(),
            client_secret: String::new(),
            medium: String::new(),
            address: String::new(),
            verification_token: String::new(),
            verified: false,
            expires_at: now + 3600, // 1 hour default
            user_id: None,
            created_at: now,
            validated_at: None,
            attempt_count: 0,
            max_attempts: 3,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;

    #[test]
    fn test_new_session() {
        let session = ThirdPartyValidationSession::new(
            "test_session".to_string(),
            "test_secret".to_string(),
            "email".to_string(),
            "test@example.com".to_string(),
            "token123".to_string(),
            Utc::now().timestamp() + 3600,
        );

        assert_eq!(session.session_id, "test_session");
        assert_eq!(session.medium, "email");
        assert_eq!(session.address, "test@example.com");
        assert!(!session.verified);
        assert_eq!(session.attempt_count, 0);
        assert_eq!(session.max_attempts, 3);
    }

    #[test]
    fn test_expiration() {
        let session = ThirdPartyValidationSession {
            expires_at: Utc::now().timestamp() - 1, // Expired 1 second ago
            ..Default::default()
        };

        assert!(session.is_expired());
        assert!(!session.is_valid_for_verification());
    }

    #[test]
    fn test_verification() {
        let mut session = ThirdPartyValidationSession::default();
        assert!(!session.verified);
        assert!(session.validated_at.is_none());

        session.mark_verified();
        assert!(session.verified);
        assert!(session.validated_at.is_some());
    }

    #[test]
    fn test_attempt_tracking() {
        let mut session = ThirdPartyValidationSession::default();
        assert_eq!(session.attempt_count, 0);
        assert!(!session.max_attempts_reached());

        session.increment_attempts();
        session.increment_attempts();
        session.increment_attempts();

        assert_eq!(session.attempt_count, 3);
        assert!(session.max_attempts_reached());
        assert!(!session.is_valid_for_verification());
    }
}
